/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Map_loader.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: trobicho <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/11/28 17:47:20 by trobicho          #+#    #+#             */
/*   Updated: 2019/12/02 09:40:59 by trobicho         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Map_loader.h"
#include <iostream>

Map_loader::Map_loader(Vdb_test &my_vdb, My_vulkan &vulk, Player &player)
					: m_vdb(my_vdb), m_vulk(vulk), m_player(player)
					, m_map(0), m_moore_access(m_vdb)
					, m_mesh(m_moore_access)
{
	m_mesh.reset();
}

static s_vec3i
		dist_from_chunk(s_vec3i pos, s_chunk &chunk)
{
	s_vec3i		d;

	d.x = chunk.origin.x - pos.x;
	if (d.x < 0)
		d.x = -d.x - (1 << CHUNK_LOG_X);
	d.y = chunk.origin.y - pos.y;
	if (d.y < 0)
		d.y = -d.y - (1 << CHUNK_LOG_Y);
	d.z = chunk.origin.z - pos.z;
	if (d.z < 0)
		d.z = -d.z - (1 << CHUNK_LOG_Z);
	return (d);
}

void	Map_loader::thread_loader()
{
	s_vbox		box;
	uint32_t	value;

	while (!m_quit)
	{
		if (m_update == false)
		{
			glm::vec3	p_pos = m_player.get_cam_pos();
			s_vec3i	i_pos = s_vec3i((int)p_pos.x, (int)p_pos.y, (int)p_pos.z);
			if (i_pos.x > 0 && i_pos.z > 0)
			{
				if (m_vdb.get_interresting_node(s_vec3i(i_pos.x, 0, i_pos.z), value)
						->get_child_slog().x >= CHUNK_LOG_X)
				{
					std::cout << "load new chunk" << std::endl;
					box.len = s_vec3i(1 << CHUNK_LOG_X, 1 << CHUNK_LOG_Y, 1 << CHUNK_LOG_Z);
					box.origin = s_vec3i((i_pos.x >> CHUNK_LOG_X) << CHUNK_LOG_X
							, 0, (i_pos.z >> CHUNK_LOG_Z) << CHUNK_LOG_Z);
					generate_one_chunck(box);
					mesh_one_chunck(box);
					std::cout << "new vbo size = " << m_mesh.vertex_buffer.size() << std::endl;
					std::cout << "new ibo size = " << m_mesh.index_buffer.size() << std::endl << std::endl;
					m_update = true;
				}
			}
		}
	}
}

void	Map_loader::update()
{
	m_update = false;
	m_old_size_vbo = m_mesh.vertex_buffer.size();
	m_old_size_vbo = m_mesh.index_buffer.size();
}

int		Map_loader::generate_one_chunck(s_vbox &box)
{
	auto	time = std::chrono::high_resolution_clock::now();
	if (m_map.generate(m_vdb, box))
		return (1);
	auto	gtime = std::chrono::high_resolution_clock::now();
	auto	time_gen = std::chrono::duration<float
			, std::chrono::seconds::period>(gtime - time).count();
	time = std::chrono::high_resolution_clock::now();
	m_vdb.pruning(); // one?
	std::cout << "time to generate = " << time_gen << std::endl;
	return (0);
}

int		Map_loader::mesh_one_chunck(s_vbox &box)
{
	if (m_nb_chunk < MAX_CHUNK)
	{
		mesh_one_chunck(box, m_nb_chunk);
		m_nb_chunk++;
		return (1);
	}
	return (0);
}

int		Map_loader::mesh_one_chunck(s_vbox &box, uint32_t chunk_id)
{
	auto	time = std::chrono::high_resolution_clock::now();
	m_chunk[chunk_id].start_offset = m_mesh.vertex_buffer.size();
	m_chunk[chunk_id].start_offset_idx = m_mesh.index_buffer.size();
	m_vdb.mesh(m_mesh, box);
	auto	mtime = std::chrono::high_resolution_clock::now();
	auto	time_mesh = std::chrono::duration<float
		, std::chrono::seconds::period>(mtime - time).count();
	std::cout << "time to mesh = " << time_mesh << std::endl;
	m_chunk[chunk_id].size = m_mesh.vertex_buffer.size() - m_chunk[chunk_id].start_offset;
	m_chunk[chunk_id].size_idx = m_mesh.index_buffer.size() - m_chunk[chunk_id].start_offset_idx;
	m_chunk[chunk_id].origin = box.origin;
	return (0);
}
